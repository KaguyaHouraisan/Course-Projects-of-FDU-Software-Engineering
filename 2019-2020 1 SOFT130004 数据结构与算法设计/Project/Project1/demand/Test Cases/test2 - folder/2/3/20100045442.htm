<HTML>
<HEAD>
<STYLE TYPE="text/css">
	PRE { font-family: "Times New Roman"; font-size: 12pt; }
</STYLE>
<BASE TARGET="_top">
<TITLE>United States Patent Application: 0100045442</TITLE></HEAD>
<BODY BGCOLOR="#FFFFFF">
<a name="top"></a>
<!-BUF1=0100045442
BUF51=0
BUF2=20100045442
-->
<center>
<IMG SRC="/netaicon1/PTO/AppFThdr.gif">
</center>  
<center>
<!-- <IMG border=0 src=/netaicon1/PTO/titlebar.gif><br> -->
<A HREF="/netahtml/PTO/help/help.html"><IMG BORDER="0" WIDTH="63" HEIGHT="24"  align=middle SRC="/netaicon1/PTO/help.gif" ALT="[Help]"></A>
<a href="http://www.uspto.gov/patft/index.html"><img src="/netaicon1/PTO/home.gif" alt="[Home]" border="0" width="63" height="24" align=middle></a>
<a href="/netahtml/PTO/search-bool.html"><img src="/netaicon1/PTO/boolean.gif" alt="[Boolean Search]" border="0" width="63" height="24" align=middle></a>
<A HREF="/netahtml/PTO/search-adv.html"><IMG WIDTH="63" HEIGHT="24" BORDER="0" SRC="/netaicon1/PTO/manual.gif" ALT="[Manual]" align=middle></A>
<a href="/netahtml/PTO/srchnum.html"><img src="/netaicon1/PTO/number.gif" alt="[Number Search]" border="0" width="63" height="24" align=middle></a>
<A HREF="http://www.uspto.gov/go/ptdl/">
<IMG width=63 height=24 border=0 SRC="/netaicon1/PTO/ptdl.gif" ALT="[PTDLs]" align=middle></A>
</center>
<center><A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=8&p=1&f=S&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/hitlist.gif border=0 ALT=[CURR_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=8&p=2&f=S&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/nextlist.gif border=0 ALT=[NEXT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=7&p=1&f=G&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=9&p=1&f=G&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>
<a href="#bottom"><img src="/netaicon1/PTO/bottom.gif" align=middle border=0></A>
<br><A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//appft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.html%26r%3D8%26p%3D1%26f%3DG%26l%3D50%26d%3DPG01%26S1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).AB.%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(%252522Security%252Bprotocol%252522%252Bor%252B%252522Authentication%252Bprotocol%252522)&backLabel1=Back%20to%20Published%20Application%20Number%3A%2020100045442">
<img border=0 src="/netaicon1/PTO/cart.gif" border=0 alt="[Shopping Cart]"></A>
<A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=US20100045442&backUrl1=http%3A//appft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.html%26r%3D8%26p%3D1%26f%3DG%26l%3D50%26d%3DPG01%26S1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).AB.%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(%252522Security%252Bprotocol%252522%252Bor%252B%252522Authentication%252Bprotocol%252522)&backLabel1=Back%20to%20Published%20Application%20Number%3A%2020100045442">
<img border=0 src="/netaicon1/PTO/order.gif" alt="[Order Copy]"></A>
</center>
<CENTER>
<a href=http://aiw1.uspto.gov:80/.aiw?Docid=20100045442&homeurl=http%3A%2F%2Fappft1.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.html%2526r%3D8%2526p%3D1%2526f%3DG%2526l%3D50%2526d%3DPG01%2526S1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).AB.%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))%2526OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(%252522Security%252Bprotocol%252522%252Bor%252B%252522Authentication%252Bprotocol%252522)%2526RS%3D(ABST%2F(RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522)%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))&PageNum=&Rtype=&SectionNum=&idkey=DA09F41D0958
><img src="/netaicon1/PTO/image.gif" alt="[Image]" border="0" width="63" height="24" align="middle"></A>
</CENTER>
<p>
<TABLE border=0>
<TR><TD VALIGN=TOP ALIGN=LEFT width=40>
&nbsp;
</TD>
<TD VALIGN=TOP ALIGN=LEFT width=40>
&nbsp;
</TD>
<TD VALIGN=TOP ALIGN=RIGHT WIDTH=50>
</TD><TD ALIGN=RIGHT VALIGN=BOTTOM WIDTH=500><FONT SIZE=-1>( <STRONG>8</STRONG></FONT> <FONT SIZE=-2>of</FONT> <STRONG><FONT SIZE=-1>65</STRONG> )</FONT></TD></TR></TABLE>
<HR>
<TABLE WIDTH="100%">
<TR>	<TD ALIGN="LEFT" WIDTH="50%"><B>United States Patent Application</B></TD>
	<TD ALIGN="RIGHT" WIDTH="50%"><B>20100045442
</B></TD>
</TR>
  <TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="50%"><B>Kind Code</B>
  </TD><TD ALIGN="RIGHT" WIDTH="50%">                    
  <B>A1
</B></TD></TR>
<TR><TD ALIGN="LEFT" WIDTH="50%"><b>
LU; Li
; &nbsp et al.</B>
</TD><TD ALIGN="RIGHT" WIDTH="50%"> <B>
February 25, 2010
</B></TD>
</TR>
</TABLE><HR>
<font size="+1">RFID Privacy-Preserving Authentication System and Method
</font><BR>
<BR><CENTER><B>Abstract</B></CENTER>
<P>A system and method for <B><I>RFID</I></B> privacy-preserving authentication is
     disclosed. The method first has a reader sending a request and a first
     random number to a tag. The tag then generates a second random number. A
     plurality of hash values are then computed at the tag. Each hash value
     uses the first random number, the second random number and at least one
     part of a key of the tag as inputs. The second random number and the
     computed hash values are then sent to the reader. Lastly, the reader
     identifies a validity of the tag from the received values. The hash
     values are all generated in parallel and are independent to each other.
</P>
<HR>
<TABLE WIDTH="100%">
<TR> <TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Inventors:</TD>
<TD ALIGN="LEFT" WIDTH="90%">
 <B>LU; Li</B>; <I>(Hong Kong, HK)</I>
<B>; LIU; Yunhao</B>; <I>(Hong Kong, HK)</I>
<B>; HAN; Jinsong</B>; <I>(Hong Kong, HK)</I>

</TD>
</TR>  <TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Correspondence Address:
  </TD><TD ALIGN="LEFT" WIDTH="90%">
  <B><PRE>    EAGLE IP LIMITED
    13/F, Bright Way Tower, 33 Mong Kok Road
    Kowloon
    HK
</PRE></B>
  </TD></TR>
<TR> <TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Assignee:</TD>
<TD ALIGN="LEFT" WIDTH="90%">

<B>Hong Kong R&D Centre for Logistics and Supply Chain Management Enabling Technologies Limited</B><BR>
<B>Hong Kong</B><BR>
<B>HK</B><BR>
<BR>

</TD>
</TR>
<TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%" NOWRAP>Serial No.:
</TD><TD ALIGN="LEFT" WIDTH="90%">                    
<B>544214</B></TD></TR>
  <TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Series Code:
  </TD><TD ALIGN="LEFT" WIDTH="90%">                    
  <B>12
</B></TD></TR>
  <TR><TD VALIGN="TOP" ALIGN="LEFT" WIDTH="10%">Filed:
  </TD><TD ALIGN="LEFT" WIDTH="90%">                    
  <B>August 19, 2009</B></TD></TR>
</TABLE>
<p>
<TABLE WIDTH="100%">
  <TR><TD VALIGN=TOP ALIGN="LEFT" WIDTH="40%"><B>Current U.S. Class:</B></TD>
  <TD VALIGN=TOP ALIGN="RIGHT" WIDTH="60%"><B>340/10.3</B>; 380/277; 380/45; 713/168  </TD></TR>  
  <TR><TD VALIGN=TOP ALIGN="LEFT" WIDTH="40%"><B>Class at Publication:</B></TD>
  <TD VALIGN=TOP ALIGN="RIGHT" WIDTH="60%"><B>340/10.3</B>; 713/168; 380/277; 380/45  </TD></TR>
  <TR><TD VALIGN=TOP ALIGN="LEFT" WIDTH="40%"><B>International Class: </B></TD>
  <TD VALIGN=TOP ALIGN="RIGHT" WIDTH="60%">H04Q 5/22 20060101 H04Q005/22; H04L 9/32 20060101 H04L009/32; H04L 9/14 20060101 H04L009/14</TD></TR>
</TABLE>
<HR>
<CENTER><B><I>Claims</B></I></CENTER>
<HR>
<BR><BR>1. A method of authentication between a first device and at least one
     second device, comprising the steps of:a) sending a first random number
     from said first device to said second device; said second device
     comprising at least one key;b) generating a second random number at said
     second device;c) computing a plurality of cryptographic values at said
     second device using a cryptographic function; each said cryptographic
     value computed using said first random number, said second random number,
     and at least a portion of one of said at least one key of said second
     device as inputs;d) sending said second random number and said plurality
     of cryptographic values from said second device to said first device;
     said first device having access to a key database comprising said at
     least one key of said at least one second device;e) identifying the
     validity of said second device at said first device from said second
     random number and said plurality of cryptographic values received from
     said second device;wherein each cryptographic value can be computed
     independent of the others.
<BR><BR>2. The method of claim 1, wherein said first device is an RFID reader and
     said second device is an RFID tag.
<BR><BR>3. The method of claim 1, wherein said at least one key in said second
     device comprises a path key and a leaf key, said path key split into a
     plurality of parts, said plurality of cryptographic values computed in
     said computing step comprises:a) at least one cryptographic value
     computed using said first random number, said second random number and
     one of said plurality of parts of said path key of said second device as
     inputs; andb) a cryptographic value computed using said first random
     number, said second random number and said leaf key of said second device
     as inputs.
<BR><BR>4. The method according to claim 3, wherein said path key and said leaf
     key are randomly generated, such that said path key and said leaf key of
     one second device are independent to that of another second device.
<BR><BR>5. The method according to claim 3, wherein said keys in said key database
     are stored using a sparse tree data structure arranged in multiple levels
     having a root node at the top level and a plurality of leaf nodes at the
     lowest level; said root node connected to said plurality of leaf nodes
     via non-leaf nodes at levels between said top level and said lowest
     level; said root node and said non-leaf nodes further storing a set of
     index numbers; said leaf key associated with said leaf node and said path
     key corresponded to the path that traverses said path tree from said top
     node to said leaf node; and said identifying step further comprising the
     steps of:a) performing the following substeps starting from said root
     node and traversing to said non-leaf nodes until a leaf nodes is
     reached:i) computing a path cryptographic value at said first device
     using said first random number, said second random number and one of at
     least one said index number stored in said node of said sparse tree;ii)
     comparing said path cryptographic value to said cryptographic values
     received from said second device using said first random number, said
     second random number and a portion of said path key of said second device
     as inputs;iii) if a match is found, moving to a node which said index
     number refers to; otherwise repeating steps i) and ii) using another
     index number until all index numbers have been tried;iv) repeating steps
     i) to iii) using another cryptographic value received from said second
     device based on another part of said path key, until a leaf node is
     reached;b) computing a second cryptographic value at said first device
     using said first random number, said second random number received from
     said second device and said leaf key associated to said leaf node, andc)
     declaring said second device is valid if said second cryptographic value
     is identical to a cryptographic value received from said second device
     using said first random number, said second random number and said leaf
     key of said second device.
<BR><BR>6. The method according to claim 5, further comprises the step of updating
     said path key and said leaf key of said second device if said second
     device is valid.
<BR><BR>7. The method according to claim 6, wherein said updating step further
     comprising the steps of:a) generating a new path and a new leaf node at
     said sparse tree that is free from collision with the corresponding new
     path key and new leaf key at said first device; said generating step
     further comprising the substeps of:i) computing said new path key
     k.sub.i.sup.p.sup.s by computing a cryptographic value h(r.sub.1,
     r.sub.2, k.sub.i.sup.p, k.sub.i.sup.l) using said first random number
     r.sub.1, said second random number r.sub.2, said path key k.sub.i.sup.p
     and said leaf key k.sub.i.sup.l of said second device as inputs;ii)
     computing said new leaf key of said second device at said first device by
     computing a cryptographic value using said first random number, said
     second random number and said leaf key as inputs:iii) if collision
     occurs, incrementing the collision counter s by one and repeating steps
     i) and ii) using said new path key k.sub.i.sup.p.sup.s as path key
     k.sub.i.sup.p until no collision occursb) removing said leaf node
     associated to said second device in said sparse tree;c) adding a new leaf
     node in said sparse tree according to said new path key, with said new
     leaf key associated to said new leaf node;d) sending a synchronization
     message .sigma.'=(s, h(r.sub.1, r.sub.2, k.sub.i.sup.p .sup.s),
     h(r.sub.1, r.sub.2, k.sub.i.sup.l)) from said first device to said second
     device, wheres is the value of said collision counter;h(r.sub.1, r.sub.2,
     k.sub.i.sup.p.sup.s) is a path cryptographic value using said first
     random number, said second random number and said new path key as inputs,
     andh(r.sub.1, r.sub.2, k.sub.i.sup.l) is a leave cryptographic value
     using said first random number, said second random number and said new
     leaf key as inputs;e) creating said new path key at said second device by
     recursively computing said path cryptographic value according to the
     following equations: {           k i p  _  1  =  k i p           k i p  _
      s  =  h (   r 1  ,  r 2  ,    k i p  _   s - 1   ,  k i l   )
     ##EQU00002## f) assembling a second synchronization message .sigma.'=(s,
     h(r.sub.1, r.sub.2, k.sub.i.sup.p.sup.s), h(r.sub.1, r.sub.2,
     k.sub.i.sup.l)) where k.sub.i.sup.l=h(r.sub.1, r.sub.2, k.sub.i.sup.l)g)
     updating said path key and said leaf key at said second device if .sigma.
     is identical to .sigma.'; andh) returning error if .sigma. is not the
     same as .sigma.'.
<BR><BR>8. The method according to claim 3, wherein said plurality of parts of
     said path key is not of a same length.
<BR><BR>9. A system of authentication, comprising:a) at least one second device,
     each said second device comprising a path key and a leaf key;b) a key
     database storing said path key and said leaf key in a sparse tree data
     structure; said sparse tree arranged in multiple levels having a root
     node at the top level and a plurality of leaf nodes at the lowest level;
     said root node connected to said plurality of leaf nodes via non-leaf
     nodes at levels between said top level and said lowest level; said root
     node and said non-leaf nodes further storing a set of index numbers;said
     leaf key associated with said leaf node and said path key corresponded to
     the path that traverses said sparse tree from said top node to said leaf
     node;c) a first device, said first device having access to a key
     database;wherein during authentication, said first device generates a
     first random number and sends to said second device, said second
     devicegenerates a second random number,computes a plurality of
     cryptographic values using a cryptographic function wherein each said
     cryptographic value computed independent of the others, and sends said
     second random number and said computed cryptographic values to said first
     device in which a validity of said second device is identified.
<BR><BR>10. The system of claim 9, wherein said first device is an RFID reader and
     said second device is an RFID tag.
<BR><BR>11. The system according to claim 9, wherein said path key is divided in
     to a plurality of parts, said computed cryptographic values comprises:a)
     at least one cryptographic value computed using said first random number,
     said second random number and one of said plurality of parts of said path
     key as inputs; andb) a cryptographic value computed using said first
     random number, said second random number and said leaf key as inputs.
<BR><BR>12. The system according to claim 11, wherein said plurality of parts of
     said path key is not of a same length.
<BR><BR>13. The system according to claim 12, wherein said path key and said leaf
     key are randomly generated, and said path key and said leaf key of said
     at least one second device are independent to that of each other.
<BR><BR>14. The system according to claim 9, wherein said first device further
     updates said path key and said leaf key of said at least one second
     device by computing a new path key and a new leaf key.
<BR><BR>15. The system according to claim 9, wherein said first device comprises
     said key database.
<BR><BR>16. The system according to claim 9, wherein said key database is stored
     in an external data server and said first device accesses said key
     database via a data communication network.
<HR>
<CENTER><B><I>Description</B></I></CENTER>
<HR>
<BR><BR>CROSS-REFERENCE TO RELATED APPLICATION
<BR><BR>[0001]This application claims benefit under 35 U.S.C. .sctn.119(e) of U.S.
     Provisional Application having Ser. No. 61/136,257 filed Aug. 22, 2008,
     which is hereby incorporated by reference herein in its entirety.
<BR><BR>FIELD OF INVENTION
<BR><BR>[0002]This invention relates to authentication systems, in particular a
     privacy-preserving authentication system.
<BR><BR>BACKGROUND OF INVENTION
<BR><BR>[0003]Many service providers need to authenticate a device before
     extending the service to that device. A good authentication system will
     also protect the privacy and identity of the device from malicious
     attacks. When the number of devices requesting the service is large, it
     is a challenge to scale up the authentication process yet providing
     reasonable response time. This is the challenge that is faced in many
     Radio-Frequency Identification (RFID) applications.
<BR><BR>[0004]In RFID systems, RF tags emit their unique serial numbers to RF
     readers when they are being interrogated. Without privacy protection,
     however, any reader can identify a tag ID via the emitted serial number.
     Indeed, within the scanning range, a malicious reader can easily perform
     bogus authentication with detected tags to retrieve sensitive
     information. Currently, as most tags indicate the unique information of
     the items, a customer carrying those tags is subject to silent track from
     unauthorized readers. Sensitive personal information might be exposed.
     Clearly, a secure RFID system must meet two requirements. On the one
     hand, a valid reader must be able to identify the valid tags; on the
     other hand, misbehaving readers should not be able to retrieve private
     information from those tags.
<BR><BR>[0005]In order to protect user privacy, Privacy-Preserving Authentication
     (PPA) is introduced into the interactive procedure between RFID readers
     and tags. To achieve PPA, an RFID tag performs a cryptography enabled
     challenging-response procedure with a reader. For example, we can let
     each tag share a distinct key with the reader. During authentication, the
     reader first probes a tag via a query message with a nonce. Instead of
     using the plaintext to directly answer the query, the tag encrypts the
     nonce and reply the cipher to the reader. The back-end database of the
     reader searches all keys that it holds, and find a proper key to recover
     the authentication message (if it does find one), and thereby identify
     the tag. (For simplicity, we will use the term "reader" to denote the
     reader device as well the back-end database in what follows) If the tag
     is invalid, it cannot provide a proper cipher related to a key owned by
     the reader. In this procedure, the tag does not expose its identity to
     any third party. Meanwhile, the key used for encrypting messages is only
     known by valid readers. A malicious reader cannot identify a user via
     probing the valid tag.
<BR><BR>[0006]Being simple and secured, such a PPA based design suffers poor
     scalability. Upon receiving a cipher of nonce, the reader needs a prompt
     lookup to locate a key in the database. Clearly, the search complexity is
     O(N), where N is the number of all the possible tags, even only a small
     portion of them are in the reader's range. In today's large-scale RFID
     systems, N is often as large as hundreds of millions, and thousands of
     tags may respond to a reader simultaneously, demanding a fast key-search
     method as well as a carefully designed key-storage structure. Hence,
     balance-tree based schemes are proposed to accelerate the authentication
     procedure, in which the lookup complexity is O(log N).
<BR><BR>[0007]The existing balance-tree based approaches are efficient,
     nevertheless, not secured due to the key-sharing feature of
     balance-trees. As the key storage infrastructure of balance-tree based
     approaches is static, each tag, more or less, shares some common portions
     of keys with other tags (we use normal tags to denote those tags which
     are not tampered with). Consequently, compromising one tag might reveal
     information of other tags. L. Lu et al. evaluate the damage caused by
     compromising attacks to balance tree-based approaches: In a RFID system
     containing 2.sup.20 tags, and employing binary tree as the key tree, an
     adversary, by compromising only 20 tags, has a probability of nearly 100%
     to be able to track normal tags.
<BR><BR>[0008]To mitigate the impact of compromising attacks, L. Lu et al. propose
     a dynamic key-updating scheme, Strong and lightweight RFID Private
     <B><I>Authentication protocol</I></B> (SPA), for balance tree-base approaches. The
     key-updating of SPA reduces the number of keys shared among compromised
     and normal tags, and alleviate the damage caused by compromising attacks.
     SPA, however, does not completely eliminate the impact of compromising
     attacks. For instance, using SPA in a RFID system with 2.sup.20 tags, the
     probability of tracking normal tags is near to 60% after an adversary
     compromises 20 tags.
<BR><BR>[0009]Another drawback for balance-tree based PPAs is the large space
     needed to store keys in each tag. Balance-tree based approaches require
     each tag to hold O(log.sub..delta.Y) keys, and the reader to store
     .delta.N keys, where .delta. is a branch factor of the key tree.
     Obviously, due to the limited memory capacity of current RF tags,
     existing PPAs are difficult to be applied in current RFID systems.
<BR><BR>SUMMARY OF INVENTION
<BR><BR>[0010]In the light of the foregoing background, it is an object of the
     present invention to provide an alternate authentication method and
     system, called Anti-Compromising authenticaTION (ACTION) below. This
     alternate method can be applied to RFID system or any other systems that
     require authentication.
<BR><BR>[0011]Accordingly, the present invention, in one aspect, is a method of
     authentication between a first device and at least one second device,
     which includes the steps of:   [0012]i) sending a first random number
     from the first device to the second device; the second device including
     at least one key; [0013]ii) generating a second random number at the
     second device; [0014]iii) computing a plurality of cryptographic values
     at the second device using a cryptographic function; [0015]iv) sending
     the second random number and the plurality of cryptographic values from
     the second device to the first device, where the first device can have
     access to a key database that stores at least one key of at least one
     second device; [0016]v) identifying the validity of the second device at
     the first device from the second random number and the plurality of
     cryptographic values received from the second device.
<BR><BR>[0017]Each cryptographic value is computed using the first random number,
     the second random number, and at least a portion of one of at least one
     key of the second device as inputs. Each cryptographic value can be
     computed independent of the others.
<BR><BR>[0018]In another embodiment, the keys in the key database are stored using
     a sparse tree data structure arranged in multiple levels. The sparse tree
     has a root node at the top level and a plurality of leaf nodes at the
     lowest level. The root node is connected to the plurality of leaf nodes
     via non-leaf nodes at levels between the top level and the lowest level.
     The root node and the non-leaf nodes further store a set of index
     numbers. The leaf key is associated with the leaf node and the path key
     corresponded to the path that traverses the path tree from the top node
     to the leaf node. The identifying step further contains the steps of:
     [0019]performing the following substeps starting from the root node and
     traversing to the non-leaf nodes until a leaf nodes is reached:
     [0020](i) computing a path cryptographic value at the first device using
     the first random number, the second random number and one of at least one
     the index number stored in the node of the sparse tree; [0021](ii)
     comparing the path cryptographic value to the cryptographic values
     received from the second device using the first random number, the second
     random number and a portion of the path key of the second device as
     inputs; [0022](iii) if a match is found, moving to a node which the index
     number refers to; otherwise repeating steps i) and ii) using another
     index number until all index numbers have been tried; [0023](iv)
     repeating steps i) to iii) using another cryptographic value received
     from the second device based on another part of the path key, until a
     leaf node is reached;   [0024]computing a second cryptographic value at
     the first device using the first random number, the second random number
     received from the second device and the leaf key associated to the leaf
     node, and [0025]declaring the second device to be valid if the second
     cryptographic value is identical to a cryptographic value received from
     the second device using the first random number, the second random number
     and the leaf key of the second device.
<BR><BR>[0026]In another exemplary embodiment of the present invention, the method
     further updates the path key and the leaf key of the tag if the tag is
     valid.
<BR><BR>[0027]In another aspect of the current invention, a system of
     authentication contains at least one second device, a key database, and a
     first device. Each second device contains a path key and a leaf key. The
     first device which has access to a key database. The key database stores
     the path key and the leaf key in a sparse tree data structure. The sparse
     tree is arranged in multiple levels having a root node at the top level
     and a plurality of leaf nodes at the lowest level. The root node is
     connected to the plurality of leaf nodes via non-leaf nodes at levels
     between the top level and the lowest level. The root node and the
     non-leaf nodes further store a set of index numbers. The leaf key is key
     is associated with the leaf node and the path key corresponded to the
     path that traverses the sparse tree from the top node to the leaf node.
     During authentication, the first device generates a first random number
     and sends to the second device. The second device generates a second
     random number and computes a plurality of cryptographic values using a
     cryptographic function. Each cryptographic value computed is independent
     of the others. The second device sends the second random number and the
     computed cryptographic values to the reader, in which a validity of the
     tag is identified.
<BR><BR>[0028]In a preferred embodiment, the keys in the key database are stored
     using a sparse tree data structure arranged in multiple levels. The
     sparse tree has a root node at the top level and a plurality of leaf
     nodes at the lowest level. The root node is connected to the plurality of
     leaf nodes via non-leaf nodes at levels between the top level and the
     lowest level. The root node and the non-leaf nodes further store a set of
     index numbers. The leaf key is associated with the leaf node and the path
     key corresponded to the path that traverses the path tree from the top
     node to the leaf node. The identifying step further contains the steps
     of:   [0029]i) performing the following substeps starting from the root
     node and traversing to the non-leaf nodes until a leaf nodes is reached:
     [0030]computing a path cryptographic value at the first device using the
     first random number, the second random number and one of at least one the
     index number stored in the node of the sparse tree; [0031]comparing the
     path cryptographic value to the cryptographic values received from the
     second device using the first random number, the second random number and
     a portion of the path key of the second device as inputs; [0032]if a
     match is found, moving to a node which the index number refers to;
     otherwise repeating steps i) and ii) using another index number until all
     index numbers have been tried; [0033]repeating steps i) to iii) using
     another cryptographic value received from the second device based on
     another part of the path key, until a leaf node is reached;   [0034]ii)
     computing a second cryptographic value at the first device using the
     first random number, the second random number received from the second
     device and the leaf key associated to the leaf node, and [0035]iii)
     declaring the second device to be valid if the second cryptographic value
     is identical to a cryptographic value received from the second device
     using the first random number, the second random number and the leaf key
     of the second device.
<BR><BR>[0036]The present invention effectively defends against compromising
     attacks. If an attacker can track a normal tag with probability larger
     than .alpha., it must tamper with more than (N-1/.alpha.) tags, while in
     previous balance-tree based approaches, by compromising O(log N) tags, an
     attacker can track a normal tag with the probability close to 1.
<BR><BR>[0037]Another salient feature of this design is low storage requirements.
     For an overall system having N tags, ACTION only requires each tag to
     store two keys (for example 128 bits) and the reader to store 2N keys,
     achieving high storage efficiency for both readers and tags, making this
     design practical for today's RF tags. In contrast, existing tree-based
     approaches has to store at least O(log N) keys in each tag and .delta.N,
     .delta..gtoreq.2, keys in the backend application.
<BR><BR>[0038]In ACTION, the diverse branching factors will enhance the security
     of RFID systems. This feature poses significant advantages, such as the
     higher efficiency and security. ACTION retains high search efficiency in
     the sense that the lookup complexity is still log N, as good as the best
     of previous designs.
<BR><BR>[0039]Moreover, ACTION uses a common sparse tree as the key tree. The
     branching factor of each non-leaf node can be different. Therefore,
     without the knowledge about the exact shape of the key tree, any
     adversary cannot generate correct ciphers (authentication messages). The
     attacker thereby cannot force the valid reader to move deeper in the key
     tree for performing authentication processes, which means Deny-of-Service
     (DoS) attack can be effectively overcome if ACTION is used. As a result,
     ACTION does not need a root key to defend against DoS attacks compared to
     SPA, and gains higher storage efficiency.
<BR><BR>BRIEF DESCRIPTION OF FIGURES
<BR><BR>[0040]FIG. 1 shows a path key and a leaf key according to an embodiment of
     the present invention.
<BR><BR>[0041]FIG. 2 is a sparse tree used to organize tags, according to an
     embodiment of the present invention.
<BR><BR>[0042]FIG. 3 is a procedural flow chart of joining tags to a sparse tree,
     according to an embodiment of the present invention.
<BR><BR>[0043]FIG. 4 is an exemplary algorithm of joining a tag into a sparse
     tree, according to an embodiment of the present invention.
<BR><BR>[0044]FIG. 5 is a diagram showing mapping of the path key to a tag in a
     sparse tree, according to an embodiment of the present invention.
<BR><BR>[0045]FIG. 6 is a diagram showing the authentication process between a
     reader and a tag according to an embodiment of the present invention.
<BR><BR>[0046]FIG. 7 is an exemplary algorithm of authenticating between a reader
     and a tag, according to an embodiment of the present invention.
<BR><BR>[0047]FIG. 8 shows an example of computing a series of hash values during
     authentication, according to an embodiment of the present invention.
<BR><BR>[0048]FIG. 9 is a procedural flow chart of a reader identifying a tag
     after receiving a message from the tag, according to an embodiment of the
     present invention.
<BR><BR>[0049]FIG. 10 is an algorithm of erasing a node in a sparse tree,
     according to an embodiment of the present invention.
<BR><BR>[0050]FIG. 11 is a procedural flow chart of updating a tag with a new path
     key and new leaf key in a sparse tree, according to an embodiment of the
     present invention.
<BR><BR>[0051]FIG. 12 is an exemplary system diagram showing one reader and one
     tag, according to one embodiment of an RFID application.
<BR><BR>DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS
<BR><BR>[0052]As used herein and in the claims, "comprising" means including the
     following elements or steps but not excluding others. Moreover, "key"
     means security key that is used in computer cryptographic function.
<BR><BR>[0053]Various embodiments of the present invention will now be described
     more fully with reference to the accompanying drawings. The invention
     may, however, be embodied in many different forms and should not be
     construed as limited to the embodiments set forth herein; rather, the
     embodiments are provided so that this disclosure will be thorough and
     complete, and will fully convey the scope of the invention to those
     skilled in the art.
<BR><BR>[0054]The presented invention, termed as ACTION, is for preserving user
     privacy in authentication. In an exemplary embodiment, this invention
     provides an authentication method for an RFID system. In the following
     paragraphs, a detailed explanation of how ACTION can be designed and
     implemented for an RFID application is disclosed in full. It should not
     be construed, however, that the present invention can only be applied to
     RFID applications.
<BR><BR>[0055]ACTION mainly has four components: system initialization, tag
     identification, key-updating, and system maintenance.
<BR><BR>[0056]In the first component, a sparse tree is employed to organize keys
     for tags. In one embodiment where the key length is 128 bit long, the
     sparse tree can support 2.sup.128 tags. Two random keys (128 bits) are
     generated, denoted as path key k.sub.p and leaf key k.sub.l, to a tag and
     a corresponding path in the sparse tree according to k.sub.p value. After
     key initialization, each tag is associated to a leaf node in the tree.
     The leaf node thereby represents the key k.sub.l assigned to the tag, and
     the path from the root to the leaf node indicates the key k.sub.p. Since
     the two keys are randomly generated, keys among different tags are
     independent.
<BR><BR>[0057]For simplicity, assuming that there are N tags T.sub.i,
     1.ltoreq.i.ltoreq.N, and a reader R in the RFID system, according to an
     embodiment of the present invention. Let S denote the sparse tree used in
     ACTION. Let .delta. denote the branching factor of the key tree and d
     denote the depth of the tree. Each tag in the system is associated with a
     leaf node in S. Each tag T.sub.i shares two secret keys with the reader
     R. The secret keys shared by tag T.sub.i and reader R are denoted as
     k.sub.i.sup.p for path key 22 and leaf key k.sub.i.sup.l for leaf key 24
     in FIG. 1.
<BR><BR>[0058]Let n be the length of k.sub.i.sup.p 22 and k.sub.i.sup.l 24, i.e.
     |k.sub.i.sup.p|=|k.sub.i.sup.l|=n. As shown in FIG. 1, k.sub.i.sup.p 22
     is split into d parts; i.e.
     k.sub.i.sup.p=k.sub.i.sup.p[0]|k.sub.i.sup.p[1]| . . .
     |k.sub.i.sup.p[d-1], and the length of each k.sub.i.sup.p[m] is n/d, m=0
     . . . d-1. As an example, the first part of k.sub.i.sup.p 22, i.e.
     k.sub.i.sup.p[0] is labeled as 26 and the last part k.sub.i.sup.p[d-1] is
     labeled as 28 in the Figure. The branching factor .delta. of each
     non-leaf node in S is set as 2.sup.n/d, namely d.times.log .delta.=n. For
     example, if the key length is 128 bits and d=32, the branching factor of
     S is .delta.=2.sup.128/32=2.sup.4=16. In other words, each non-leaf node
     is able to accommodate 16 child positions in S. If the c-th child node
     exists in a child position of non-leaf node j, c is set as the index
     number of this child and record c in j. Note that a non-leaf node only
     stores the index numbers for existing children.
<BR><BR>[0059]For simplicity, let IS.sub.j denote the set of j's index numbers,
     and IN.sub.j denote the element number of IS.sub.j, i.e.
     IN.sub.j=|IS.sub.j|. An example is shown in FIG. 2, in which the
     branching factor .delta.=2.sup.4. Each non-leaf node has 16 child
     positions. For a non-leaf node a 32, as shown in FIG. 2, the reader will
     maintain its index number set 31 as IS.sub.a={5, 7}, and IN.sub.a=2.
<BR><BR>[0060]Referring to FIGS. 2 to 4, a flow chart and an algorithm for
     organizing tags in a sparse tree according to an embodiment of the
     present invention is illustrated. Initially, the tree is empty. The
     reader R generates two keys k.sub.i.sup.p and k.sub.i.sup.l uniformly at
     random for every tag T.sub.i. Meanwhile, the reader divides each
     k.sub.i.sup.p into d parts, k.sub.i.sup.p[0]|k.sub.i.sup.p[1]| . . .
     |k.sub.i.sup.p[d-1], where d is the depth of the key tree S. The reader
     distributes k.sub.i.sup.p and k.sub.i.sup.l to tag T.sub.i and organize
     k.sub.i.sup.p in S as follows. From the root, the reader generates a
     non-leaf node at each level m according to the corresponding
     k.sub.i.sup.p[m]. That is, after the reader generates a node a at the
     level m-1 according to the k.sub.i.sup.p[m-1], it will generate the
     k.sub.i.sup.p[m]-th child of node a 32, and set an index number of a as
     k.sub.i.sup.p[m]. In one exemplary embodiment as shown in FIG. 2, the
     branching factor .delta. of S is 16, and there are 4 tags in the system,
     denoted as T.sub.1, T.sub.2, T.sub.3, and T.sub.4. Assume that the length
     of path key is 12 bits. Each path key is divided into 3 parts, and the
     length of each part is 4 bits (because .delta.=16, the length of each
     part of a key should be log.sub.216=4 bits). The reader generates four
     path keys as 257, 277, 468, and 354 for tags T.sub.1-T.sub.4,
     respectively. The reader also generates four leaf keys, as k.sub.1.sup.l,
     k.sub.2.sup.l, k.sub.3.sup.l, and k.sub.4.sup.l for T.sub.1-T.sub.4,
     respectively. For T.sub.1, k.sub.1.sup.l=257 (0010|0101|0111), thus,
     k.sub.1.sup.p[0]=2, k.sub.1.sup.p[1]=5, and k.sub.1.sup.p[2]=7. The
     reader first generates a child at the root 30, and sets an index number
     as 2 (k.sub.1.sup.p[0]=2). Here the index number 2 means the root has a
     child marked as node a 32 in its second position, as illustrated in FIG.
     2. Then the reader generates a child b 34 of node a 32, and sets an index
     number of a as 5 (k.sub.1.sup.p[1]=5). Finally, the reader generates a
     child c of node b, which is a leaf node c 36, and sets an index number of
     b as 7 (k.sub.1.sup.p[2]=7). Indeed, the key organization can be
     analogous to generate a path in tree S. In the above example, the path of
     T.sub.1 is root-&gt;a-&gt;b-&gt;c as shown by step 40 in FIG. 3. After
     the same procedure is applied on tags T.sub.2, T.sub.3, and T.sub.4, as
     shown by steps 42, 46 and 48 in FIG. 3, a sparse tree is obtained as
     illustrated in FIG. 2.
<BR><BR>[0061]After key initialization, each tag is associated to a leaf node in
     the tree. The leaf node thereby represents the key k.sub.i.sup.l assigned
     to the tag, and the path from the root to the leaf node indicates the key
     k.sub.i.sup.p. An example is shown in FIG. 5 to illustrate mapping
     relationship between the path in the key tree S and the key k.sub.i.sup.p
     in the tag. For the key path k.sub.1.sup.p 62 of T.sub.1,
     k.sub.1.sup.p[0] 64 has a binary representation of 2, k.sub.1.sup.p[1] 66
     has a binary representation of 5 and k.sub.1.sup.p[2] 68 has a binary
     representation of 7. In the sparse tree S 60, at the root level,
     k.sub.1.sup.p[0] is determined to be 2 so the child node of index number
     2 is checked next. k.sub.1.sup.p[1] and k.sub.1.sup.p[2] are determined
     using the same logic and the path to tag T.sub.1 is selected as shown in
     FIG. 5.
<BR><BR>[0062]In one embodiment, ACTION employs cryptographic functions to
     generate authentication messages and update keys. In one embodiment, the
     cryptographic function is hash function. Let h denote a cryptographic
     hash function: h: {0,1}.fwdarw.{0,1}.sup.n, where n denotes the length of
     hash value. Let N be the number of all tags in the system. The basic
     authentication procedure between the reader and a tag T.sub.i
     (1.ltoreq.i.ltoreq.N) includes three phases, as illustrated in FIG. 6. In
     the first phase, the reader R sends a "Request" with a random number
     r.sub.1 (a nonce) to tag T.sub.i. In the second phase, upon receiving
     "Request", tag T.sub.i generates a random number r.sub.2 (a nonce) and
     calculates a series of hash values, h(r.sub.1, r.sub.2,
     k.sub.i.sup.p[0]), h(r.sub.1, r.sub.2, k.sub.i.sup.p[1]), . . . ,
     h(r.sub.1, r.sub.2, k.sub.i.sup.p[d-1]), h(r.sub.1, r.sub.2,
     k.sub.i.sup.l), where h(r.sub.1, r.sub.2, k) denotes the output of the
     hash function on three inputs: a key k and two random numbers r.sub.1 and
     r.sub.2. T.sub.i replies to R with a message U=(r.sub.2, h(r.sub.1,
     r.sub.2, k.sub.i.sup.p[0]), h(r.sub.1, r.sub.2, k.sub.i.sup.p[1]), . . .
     , h(r.sub.1, r.sub.2, k.sub.i.sup.p[d-1]), h(r.sub.1, r.sub.2,
     k.sub.i.sup.l)). For simplicity, we denote the elements in U as u,
     v.sub.o, v.sub.1, . . . , v.sub.d-1, v.sub.d where u=r.sub.2 and
     v.sub.j=h(r.sub.1, r.sub.2, k.sub.i.sup.j), j=0 . . . d-1,
     v.sub.d=h(r.sub.1, r.sub.2, k.sub.i.sup.l). In the third phase, R
     identifies T.sub.i using the key tree S and the received U.
<BR><BR>[0063]In this embodiment, the hash values computed by the tag T.sub.i,
     i.e. h(r.sub.1, r.sub.2, k.sub.i.sup.p[0]), h(r.sub.1, r.sub.2,
     k.sub.i.sup.p[1]), . . . , h(r.sub.1, r.sub.2, k.sub.i.sup.p[d-1]),
     h(r.sub.1, r.sub.2, k.sub.i.sup.l), are independent and do not rely on
     each other. That means all hash values can be generated in parallel.
     Compared to a method which the hash values are generated serially, the
     time used in computing hash values of the present invention is minimized.
     Also, as the process of computing hash value may induce error in the
     result, computing the hash values in parallel also minimizes the damage
     when an error is induced by the cryptographic hash function, since an
     error induced when computing one hash value will not diffuse to other
     hash values. Whereas in a serial hash value computation method, an error
     will propagate to all later computed hash values.
<BR><BR>[0064]Reader R invokes a recursive algorithm to probe a path from the root
     to a leaf in S to identify T.sub.i. In one embodiment, Algorithm 2 as
     shown in FIG. 7 is used. Assume R reaches a non-leaf node a at level m-1.
     For all index numbers stored in a, R computes a hash value with inputs as
     r.sub.1, r.sub.2, as well as the index numbers, and then compares the
     hash value with the element v.sub.m in the received U. If there is match,
     the path of T.sub.i should be extended to the child related to the index
     number. Note that here the child node is on the path assigned to T.sub.i.
     Repeating such a procedure until arriving at a leaf node, R recognizes
     the tag T.sub.i.
<BR><BR>[0065]For the example in FIG. 8, on receiving a "Request" message with a
     random r.sub.1, T.sub.1 generates a random number r.sub.2, and computes a
     serials of hash values h(r.sub.1, r.sub.2, 2), h(r.sub.1, r.sub.2,
     r.sub.2, 5), h(r.sub.1, r.sub.2, 7), and h(r.sub.1, r.sub.2,
     k.sub.i.sup.l), then replies R with the message U=(u, v.sub.o, v.sub.1,
     v.sub.2)=(r.sub.2, h(r.sub.1, r.sub.2, 2), h(r.sub.1, r.sub.2, 5),
     h(r.sub.1, r.sub.2, 7), h(r.sub.1, r.sub.2, k.sub.i.sup.l)).
<BR><BR>[0066]FIG. 9 shows a process of a reader R reading a message U sent from
     the tag T.sub.1 in one embodiment. The reader R first receives the
     message U in step 70. On receiving U, R first computes all h(r.sub.1,
     r.sub.2, x) to compare with v.sub.1 as shown in step 72. In the example
     shown here, x=2, 5 and 7, which are all the index numbers stored in the
     root. Clearly, R locates 2 as a match number and thereby moves to node a
     Then in steps 74 and 76, R locates 5 and 7 in the nodes b and node c,
     respectively. R terminates its path probing when it reaches the leaf node
     c, thereby identify T.sub.1.
<BR><BR>[0067]After successfully identifying T.sub.i, R and T.sub.i automatically
     update the key stored in T.sub.i and coordinate the change in the tree S
     as follows.
<BR><BR>[0068]The reader R makes use of a cryptographic hash function h to
     generate new keys. Let k.sub.i.sup.p and k.sub.i.sup.l be the current
     path key and leaf key used by T.sub.i. The reader R computes a new path
     key k.sub.i.sup.p from the old path key k.sub.i.sup.p and leaf key
     k.sub.i.sup.l by computing k.sub.i.sup.p=h(r.sub.1, r.sub.2,
     k.sub.i.sup.p, k.sub.i.sup.l). Similarly, R calculates the new leaf key
     as k.sub.i.sup.l=h(r.sub.1, r.sub.2, k.sub.i.sup.l). The index numbers of
     non-leaf nodes needs to be modified with care according to the new key
     k.sub.i.sup.p. Otherwise, some tag identifications can be interrupted,
     since the index number stored in non-leaf nodes might be shared among
     multiple tags
<BR><BR>[0069]In one exemplary embodiment, two algorithms are designed for
     key-updating: 1) TagJoin, as shown in FIG. 4; and 2) TagLeave, shown in
     FIG. 10. The basic idea is that one first uses the TagLeave to remove the
     path corresponding to old path key k.sub.i.sup.p of tag T.sub.i, and then
     generate a new path corresponding to the key k.sub.i.sup.p in S. It is
     possible that a non-leaf node in the path has multiple branches so that
     some keys are used by other tags, for example, the node a in FIG. 2. In
     this case, the TagLeave algorithm terminates.
<BR><BR>[0070]In FIG. 11, an example of T.sub.1's key-updating process is shown.
     In step 80, the reader R computes a new path key k.sub.i.sup.p=679 from
     the old path key k.sub.i.sup.p=257 and leaf key k.sub.i.sup.l by
     computing h(r.sub.1, r.sub.2, k.sub.i.sup.p, k.sub.i.sup.l). Similarly, R
     calculates the new leaf key as h(r.sub.1, r.sub.2, k.sub.i.sup.l).
<BR><BR>[0071]After deleting the old key in step 82 and 84, R re-generates a new
     path for tag T.sub.i according to the new key k.sub.i.sup.p using the
     TagJoin algorithm. A potential problem of new path generation is that the
     path has already existed in S, which means the key k.sub.i.sup.p has been
     generated before in the systems. The probability of this situation
     happens is quite small. First, the sparse tree is a virtual tree
     according to the initialization algorithm. Before the tag deployment, the
     tree is empty. When a path key is generated by a hash function, a route
     from a certain leaf to the root is emerged accordingly in the sparse
     tree. Therefore, a route in the sparse tree corresponds to a hash value.
     This correspondence leads to twofold facts: 1) the capability of sparse
     tree is as large as the size of the hash value space. In one embodiment
     of the present invention, a path key is a hash value with a length of 128
     bits, which indicates the sparse tree can hold 2.sup.128 routes in
     maximum, that is, the sparse tree can hold 2.sup.128 tags
     correspondingly. In any practice RFID system, however, the number of tags
     is much less than 2.sup.128. The probability of the tree becomes dense is
     negligible. 2) A route in the sparse tree corresponds to a hash value,
     Therefore, if two tags have a same route in the sparse tree, it means a
     hash collision occurs. According to the collision-resistance property of
     hash functions, the probability of collision happening is also
     negligible. For example, in an RFID system contains 2.sup.20 tags, and
     the length of path key is 128 bits, the ratio of occupied routes in the
     sparse tree is 2.sup.-108 (2.sup.20/2.sup.128) and the path key is
     generated uniformly at random. Thus, the probability of generating an
     existing route is 2.sup.-108. Combining the above analyses, it is safe to
     claim that the probability of two tags having a similar route is
     negligible.
<BR><BR>[0072]If such a collision does happen, another new key can be generated.
     In one embodiment, R first generates a new key
     k.sub.i.sup.p.sup.2=h(r.sub.1, r.sub.2, k.sub.i.sup.p, k.sub.i.sup.l),
     and then executes the TagJoin algorithm again to create a new path in S.
     R repeats such a procedure until a new path is successfully generated. R
     counts the number of TagJoin runs, denoted as s (due to the negligible
     probability of collisions, s usually equals to 1), and sends a
     synchronization message .sigma.=(s, h(r.sub.1, r.sub.2,
     k.sub.i.sup.p.sup.s), h(r.sub.1, r.sub.2, k.sub.i.sup.l) to tag T.sub.i,
     as shown in FIG. 6. Here k.sub.i.sup.p.sup.s is computed from iterative
     equations by:
<BR><BR>    {        k i p  _  1  =  k i p           k i p  _  s  =  h (   r 1  ,
     r 2  ,    k i p  _   s - 1   ,  k i l   )          ( 1 )    ##EQU00001##
<BR><BR>[0073]Having .sigma., T.sub.i first computes using k.sub.i.sup.p.sup.s and
     s with equation (1), then computes k.sub.i.sup.l=h(r.sub.1, r.sub.2,
     k.sub.i.sup.l). Thus T.sub.i gets .sigma.'=(s, h(r.sub.1, r.sub.2,
     k.sub.i.sup.p.sup.s), h(r.sub.1, r.sub.2, k.sub.i.sup.l)). After
     computing .sigma. and .sigma.', T.sub.i verifies whether or not
     .sigma.=.sigma.'. If yes, T.sub.i updates its keys as k.sub.i.sup.p.sup.s
     and k.sub.i.sup.l. Otherwise T.sub.i returns an error to reader. By doing
     that, T.sub.i can coordinate its key with the one generated by the
     reader.
<BR><BR>[0074]Since the two keys are randomly generated, keys among different tags
     are independent. In the second component the reader performs a
     logarithmic search to identify a tag. In the third component, ACTION
     performs a key-updating procedure, in which ACTION employs a
     cryptographic hash function such as MD5, SHA-1, to update the old key in
     a tag. Note that the new key is still random and independent to the keys
     used by other tags. ACTION also reduces the maintenance overhead in high
     dynamic systems where tags join or leave frequently by using the fourth
     component.
<BR><BR>[0075]If a new tag T.sub.i joins the system, R needs to find a new path in
     the key tree. In one embodiment, R invokes the TagJoin algorithm as shown
     in Algorithm 1. In a further embodiment, R generates a new path key
     k.sub.i.sup.p and leaf key k.sub.i.sup.l independent with other keys,
     then splits k.sub.i.sup.p into d parts, k.sub.i.sup.p[0],
     k.sub.i.sup.p[1], . . . , k.sub.i.sup.p[d-1]. Starting at the root, if R
     arrives at a non-leaf node j at level m, R adds k.sub.i.sup.p[m] into j's
     index number set ISj, and walks to the k.sub.i.sup.p[m]-th child of j (if
     this child does not exist, R creates it). When a leaf node is reached, R
     associates T.sub.i to the leaf node, and sets the key of the leaf node as
     k.sub.i.sup.l. A new path is generated for T.sub.i. An example is shown
     in the step 86 of FIG. 11.
<BR><BR>[0076]To withdraw a tag T.sub.i, R should erase the path from the root to
     T.sub.i's associated leaf node. In one embodiment, the TagLeave algorithm
     is used. In this algorithm, R first deletes the leaf key k.sub.i.sup.l of
     T.sub.i. Starting from the associated leaf node of T.sub.i, if R reaches
     a node e at level m, R first finds e's parent j, and then deletes
     k.sub.i.sup.p[m] from the index set IS.sub.f. After arriving at node f, R
     deletes e. R repeats this procedure until a non-leaf node in the path has
     multiple branches, for example, the node a in FIG. 2. Thus, R withdraws
     T.sub.1. An example is shown in the steps 82 and 84 of FIG. 11.
<BR><BR>[0077]The system block diagram shown in FIG. 12 depicts one exemplary
     embodiment of a RFID reader and tag assembly in which the present
     invention may be implemented. The reader 100 contains various hardware
     components such as the reader microcontroller 102, reader memory 104,
     network interface 106, reader antenna 108 and a database storage 110. The
     reader microcontroller 102 is connected to each of these components and
     serves as a central controlling unit. It will perform tasks such as
     generating random keys, calculating hash values, etc, as mentioned
     previously. The reader 100 may further communicate with external devices
     such as back-end computer servers or data stores that are not shown in
     this figure via the network interface 106. Examples of the network
     interface 106 include Wi-Fi adapter, USB port, ethernet port, etc.
<BR><BR>[0078]Typically, an RIFD tag 120 contains an antenna 128 and memory 124.
     In the invention that is disclosed here, the tag 120 also comprises a
     microcontroller 122 that performs tasks such as hash function evaluation.
     In operation, the reader 100 sends out radio frequency (RF)
     electromagnetic wave through its antenna 108. When the tag 120 is in the
     vicinity of the reader 100, its antenna 124 will pick up the
     electromagnetic wave and provide electric power to the tag 120. The
     reader 100 can then send commands for the tag 120 to execute. This may
     include the authentication procedure that the present invention
     discloses.
<BR><BR>[0079]Although FIG. 12 only shows one reader and one tag, there may be
     more than one reader and a plurality of tags in an RFID application.
     Furthermore, the database 110 in the reader 100 may hold the entire
     sparse tree that stores the path keys and the leaf keys. Alternatively,
     the sparse tree may be stored in an external data server and the reader
     100 makes use of the network interface 106 to accesses the sparse tree
     via an external data network like the local area network or wide area
     network.
<BR><BR>[0080]The exemplary embodiments of the present invention are thus fully
     described. Although the description referred to particular embodiments,
     it will be clear to one skilled in the art that the present invention may
     be practiced with variation of these specific details. Hence this
     invention should not be construed as limited to the embodiments set forth
     herein.
<BR><BR>[0081]For example, in the embodiments above, the path key k.sub.p is
     divided into equal parts with a length of n/d bits. It follows that the
     branching factor .delta. is the same for all levels of non-leaf nodes. It
     is clear to one skilled in the art that the path key does not necessarily
     be divided into equal parts. For example, k.sub.1.sup.p[0] can be of 6
     bits long, and k.sub.1.sup.p[1] can be of 3 bits long. That means the
     branching factor can vary for each level of non-leaf nodes.
<BR><BR>[0082]The detail description above teaches that each tag stores two keys,
     the length of each is 128 bits. However, one skilled in the art should
     realize it is possible to use keys with other length, for example, 256
     bits, 64 bits, etc. The length of the key chosen may depends on the
     storage limitation and/or computing power of the tag, for example.
<BR><BR>[0083]In the exemplary embodiments described above, hash functions are
     used to generate authentication messages and update keys. It is clear to
     one skilled in the art that other kinds of cryptographic functions or
     mathematical algorithms such as members of MD family, SHA-1, low cost
     RFID hash functions constructed by non-linear feedback shift registers,
     and Whirlpool, etc., can also be used to fulfill the purpose.
<BR><BR>[0084]Although the invention is directed to authentication systems using
     RFID, it can also be used in other authentication systems that involve a
     service provider and a plurality of devices that subscribe to its
     service. The invention disclosed here is therefore not restricted to only
     RFID applications.
<BR><BR><CENTER><B>* * * * *</B></CENTER>
<HR><CENTER>
<a href=http://aiw1.uspto.gov:80/.aiw?Docid=20100045442&homeurl=http%3A%2F%2Fappft1.uspto.gov%2Fnetacgi%2Fnph-Parser%3FSect1%3DPTO2%2526Sect2%3DHITOFF%2526u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.html%2526r%3D8%2526p%3D1%2526f%3DG%2526l%3D50%2526d%3DPG01%2526S1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).AB.%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))%2526OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(%252522Security%252Bprotocol%252522%252Bor%252B%252522Authentication%252Bprotocol%252522)%2526RS%3D(ABST%2F(RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522)%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))&PageNum=&Rtype=&SectionNum=&idkey=DA09F41D0958
><img src="/netaicon1/PTO/image.gif" alt="[Image]" border="0" width="63" height="24" align="middle"></A>
</CENTER>
<center>
<A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/AddToShoppingCart?docNumber=US20100045442&backUrl1=http%3A//appft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.html%26r%3D8%26p%3D1%26f%3DG%26l%3D50%26d%3DPG01%26S1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).AB.%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(%252522Security%252Bprotocol%252522%252Bor%252B%252522Authentication%252Bprotocol%252522)&backLabel1=Back%20to%20Published%20Application%20Number%3A%2020100045442">
<img border=0 src="/netaicon1/PTO/order.gif" alt="[Order Copy]"></A>
<A HREF="http://ebiz1.uspto.gov/vision-service/ShoppingCart_P/ShowShoppingCart?backUrl1=http%3A//appft1.uspto.gov/netacgi/nph-Parser?Sect1%3DPTO2%26Sect2%3DHITOFF%26u%3D%25252Fnetahtml%25252FPTO%25252Fsearch-adv.html%26r%3D8%26p%3D1%26f%3DG%26l%3D50%26d%3DPG01%26S1%3D((RFID%252BOR%252B%252522radio%252Bfrequency%252Bidentification%252522).AB.%252BAND%252B(%252522Security%252Bprotocol%252522%252BOR%252B%252522Authentication%252Bprotocol%252522))%26OS%3Dabst%2F(RFID%252Bor%252B(%252522radio%252Bfrequency%252Bidentification%252522))%252BAND%252B(%252522Security%252Bprotocol%252522%252Bor%252B%252522Authentication%252Bprotocol%252522)&backLabel1=Back%20to%20Published%20Application%20Number%3A%2020100045442">
<img border=0 src="/netaicon1/PTO/cart.gif" border=0 alt="Shopping Cart"]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=8&p=1&f=S&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/hitlist.gif border=0 ALT=[CURR_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=8&p=2&f=S&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&Query=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/nextlist.gif border=0 ALT=[NEXT_LIST]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=7&p=1&f=G&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/prevdoc.gif border=0 ALT=[PREV_DOC]></A>
<A  HREF=/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&u=%2Fnetahtml%2FPTO%2Fsearch-adv.html&r=9&p=1&f=G&l=50&d=PG01&S1=((RFID+OR+%22radio+frequency+identification%22).AB.+AND+(%22Security+protocol%22+OR+%22Authentication+protocol%22))&OS=abst/(RFID+or+(&quot;radio+frequency+identification&quot;))+AND+(&quot;Security+protocol&quot;+or+&quot;Authentication+protocol&quot;)><IMG ALIGN=MIDDLE SRC=/netaicon1/PTO/nextdoc.gif border=0 ALT=[NEXT_DOC]></A>
<a href="#top"><img align=middle src="/netaicon1/PTO/top.gif" border=0></a>
</center>
<a name="bottom"></a>
<center>
<A HREF="/netahtml/PTO/help/help.html"><IMG BORDER="0" WIDTH="63" HEIGHT="24" SRC="/netaicon1/PTO/help.gif" ALT="[Help]" align=middle></A>
<a href="http://www.uspto.gov/patft/index.html"><img src="/netaicon1/PTO/home.gif" alt="[Home]" border="0" width="63" height="24" align=middle></a>
<a href="/netahtml/PTO/search-bool.html"><img src="/netaicon1/PTO/boolean.gif" alt="[Boolean Search]" border="0" width="63" height="24" align=middle></a>
<A HREF="/netahtml/PTO/search-adv.html"><IMG WIDTH="63" HEIGHT="24" BORDER="0" SRC="/netaicon1/PTO/manual.gif" ALT="[Manual]" align=middle></A>
<a href="/netahtml/PTO/srchnum.html"><img src="/netaicon1/PTO/number.gif" alt="[Number Search]" border="0" width="63" height="24" align=middle></a>
<A HREF="http://www.uspto.gov/go/ptdl/">
<IMG width=63 height=24 border=0 SRC="/netaicon1/PTO/ptdl.gif" ALT="[PTDLs]" align=middle></A><!-- <IMG border=0 src=/netaicon1/PTO/titlebar.gif><br> -->
</center></BODY>
</HTML>